
\section{Related Work}
\label{relate}

Several approaches have been proposed to determine the best floating-point formats  as a function of the
expected accuracy on the results. Darulova and Kuncak use a forward static analysis to compute the propagation of errors
\cite{DK14}. If the computed bound on the accuracy satisfies the post-conditions then the analysis is
run again with a smaller format until the best format is found. Note that in this approach, all the values have
the same format (contrarily to our framework where each control-point has its own format).
While Darulova and Kuncak develop their own static analysis, other static techniques \cite{Gou13,Sal15} could be used to
infer from the forward error propagation the suitable formats. 
Chiang \textit{et al.} \cite{Call17} have proposed a method to allocate a precision to the terms of an arithmetic expression (only).
They use a formal analysis via Symbolic Taylor Expansions and
error analysis based on interval functions. 
In spite of our linear constraints, they solve a quadratically constrained quadratic program to obtain
 annotations.

Other approaches rely on dynamic analysis. For instance, the Precimonious tool tries to decrease the precision
of variables and checks whether the accuracy requirements are still fulfilled \cite{Nal16,Ral13}.
Lam \textit{et al} instrument binary codes in order to modify their precision without modifying the
source codes \cite{Lal13}. They also propose a dynamic search method to identify the pieces of code where the precision
should be modified.

Finally other work focus on formal methods and numerical analysis.
A first related research direction concerns formal proofs and the use of proof assistants to guaranty
the accuracy of finite-precision computations \cite{Bol15,Har07,Lee18}.
Another related research direction concerns the  compile-time optimization of programs in order to improve
the accuracy of the floating-point computation in function of given ranges for the inputs, without
modifying the formats of the numbers \cite{DMC15,Pal15}.

\section{Conclusion}
\label{conc}

In this article, we have introduced a dependent type system able to infer the accuracy of numerical computations.
This type system uses a modified Hindley-Milner algorithm which calls a SMT solver to solve linear
equations among integers to compute the accuracy information. Our type system allows one to type non-trivial 
programs corresponding to implementations of classical numerical analysis methods. Unstable computations
are rejected by the type system. The consistency of typed programs is ensured by a subject reduction theorem.

To our knowledge, this is the first type system dedicated to numerical accuracy. 
We believe that this approach has many advantages going from early debugging to
compiler optimizations. Indeed, we believe that the usual type \texttt{float} proposed by usual
\texttt{ML} implementations, and which is a simple clone of the type \texttt{int}, is too poor for numerical computations.
We also believe that this approach is a credible alternative to static analysis techniques for
numerical precision \cite{DK14,Gou13,Sal15}.
From the developper point of view, our type system
introduces few changes in the programming style, limited to giving the
accuracy of the inputs of the accuracy of comparisons to allow the typing of certain recursive functions.

A first perspective is to improve our type system in order to accept even more programs.
We would like to extend our language to mathematic elementary functions such as
$\log$, $\sin$, etc. But we would also like to explore more fundamental directions.
In some cases, there exists many solutions to the equations sent to \texttt{Z3}
and the solution given by the solver is not always the most appropriate one. Even if the
typing of a first expression $e$ is correct, other types were acceptable and the choice operated by the SMT solver
may be incompatible with the typing of other expressions who will call $e$ in the future.
To overcome this limitation, we plan to modify  our type inference algorithm to postpone as much as
possible the call to \texttt{Z3}.

A second perspective to the present work is the implementation of a compiler for \texttt{Numl}.
We aim at using the type information to select the most appropriate formats (the IEEE754 formats
of Figure \ref{formats}, multiple precisions numbers of the GMP library when needed or requested
by the user or fixed-point numbers.) At longer term, we also aim at introducing 
safe compile-time optimizations based on type preservation: an expression may be safely (from the
accuracy point of view) substituted to
another expression as long as both expressions are mathematically equivalent and that the
new expression has a greater type than the older one in the sense of Equation (\ref{eqlttype}).

Finally, a third perspective is to integrate our type system into other applicative
languages. In particular, it would be of great interest to have such a type system inside
a language used to build critical embedded systems such as the synchronous language \texttt{Lustre} \cite{Cal87}. 
In this context
numerical accuracy requirements are strong and difficult to obtain.
Our type system could be integrated naturally inside \texttt{Lustre} or similar languages.





