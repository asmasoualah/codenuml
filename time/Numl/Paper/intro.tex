

\section{Introduction}

It is well-known that numerical computations may sometimes lead to wrong results because of the accumulation of 
roundoff errors \cite{Fral17}. 
Recently, much work has been done to detect these accuracy errors in finite precision computations \cite{IEEE754}, by  static \cite{DK14,Gou13,Sal15} or dynamic 
\cite{Dal16} analysis, to find the least
data formats needed to ensure a certain accuracy (precision tuning) \cite{Lal13,Mar17,Ral13} and to optimize the accuracy by program transformation \cite{DMC15,Pal15}.
All these techniques are used late in the software development process, once the programs are entirely written.

In this article, we aim at exploring a different direction. We aim at detecting and correcting numerical accuracy errors at software development time, i.e. during the 
programming phase. From a software engineering point of view, the advantages of our approach are many since it is well-known that late bug detection is time and money 
consuming. We also aim at using intensively used techniques recognized for their ability to discard run-time errors. This choice is motivated by efficiency reasons as well as 
for end-user adopt ability reasons.

We propose a \texttt{ML}-like type system (strong, implicit, polymorphic \cite{Pie02}) for numerical computations in which the type of an 
arithmetic expression carries information on its accuracy. We  use dependent types \cite{Pie04} and a type inference algorithm which, from the user point of view, 
acts like \texttt{ML} \cite{Mal97}  type inference algorithm \cite{Pie02} even if it slightly differs in its implementation. While type systems have been widely
used to prevent a large variety of software bugs, to our knowledge, no type system has been targeted to address numerical accuracy issues in finite precision computations.
Basically, our type system accepts expressions for which it may ensure a certain accuracy on the result of the evaluation and it rejects expressions for which a minimal 
 accuracy on the result of the evaluation cannot be inferred.

In our type system, unification necessitates to solve sets
of constraints made of propositional logic formulas and relations between affine expressions over integers 
(and only integers).
Indeed, these relations remain linear even if the term to be typed contains non-linear computations.
As a consequence, these constraints can be easily checked by a SMT solver 
(we use \texttt{Z3} in practice \cite{Mou08}). 


 Let us insist on the fact that we use a dependent type system. Consequently, the type corresponding to a function of some argument $x$ 
 depends on the type of $x$ itself. 
The soundness of our type system relies on a subject reduction theorem introduced in Section \ref{correct}.
Based on an instrumented operational semantics computing both the finite precision and exact results
of a numerical computation,  this theorem shows that the error on the result of the evaluation of some expression $e$ is less 
than the error predicted by the type of $e$.
Obviously, as any non-trivial type system, our type system is not complete and rejects certain
 programs that would not produce unbounded numerical errors. 
 We show that, in practice,  our type system  is expressive enough  to type implementations 
 of usual simple numerical algorithms \cite{Atk89} such as the ones of Section \ref{morex}. 
Let us also mention that our type system represents a new application of dependent type theory motivated
by applicative needs. Indeed, dependent types arise naturally in our context since accuracy depends on values.

This article is organized as follows. Section \ref{over} introduces informally our type system and shows how it is used in our implementation of 
a \texttt{ML}-like programming language, \texttt{Numl}.
The formal definition of the types and of the inference rules are given in Section \ref{infe}.
Section \ref{secdeftypes} introduces the type system itself while Section \ref{secdefprim}
introduces the types of the primitives of the language.
A soundness theorem is given in Section \ref{correct}. 
The implementation of the type system is discussed in Section \ref{implem}.
Sections \ref{unif} and \ref{morex} present the unification algorithm and experimental results, respectively.
Section \ref{ieee} discuss the special case of the IEEE754 floating-point arithmetic \cite{IEEE754}.
Section \ref{relate} describes related work 
 and Section \ref{conc} concludes.
